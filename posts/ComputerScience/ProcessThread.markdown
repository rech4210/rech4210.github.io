---
layout: post
title: "프로세스와 스레드"
description:
date: 2024-04-21 16:17:04 +0900
tags : ComputerScience
---

# 프로세스
 프로세스는 실행중인 프로그램을 나타낸다
 - 포그라운드 프로세스
	 - 사용자가 실행 상태를 볼 수 있는 프로세스
 - 백그라운드 프로세스
	 - 사용자가 못 보는 실행 상태의 프로세스
	 - daemon, 서비스 : 사용자와 상호작용없이 정해진 기능만 실행하는 프로세스

## 프로세스 제어 블록
프로세스는 CPU에 요청해 실행되는데 반해 CPU 자원은 한정되어 있다.
이를 위해 프로세스들은 한정된 시간 만큼만 CPU를 이용한다. 자신의 실행 차례에 정해진 시간만큼 CPU 자원을 이용하고 타이머 인터럽트가 발생하면 차례를 양보하게 된다.

![image](https://github.com/rech4210/rech4210.github.io/assets/65288322/5eb22e35-26c6-4421-be32-9bddccdae9fa)

이를 위해 사용하는 자료구조를 PCB (프로세스 제어 블록)이라 부른다. PCB는 프로세스 관련 정보를 저장하며 프로세스 생성 시 커널 영역에 생성, 종료 시 폐기된다.

### PCB 정보
운영체제마다 상이하나 기본적인 내용은 비슷하다.
운영체제는 커널영역에 적재된 PCB의 정보를 보고 프로세스를 관리한다.
- 프로세스 ID (식별 고유번호)
- 레지스터 값
	- 프로세스는 자신의 실행 차례가 오면 실행 재개를 하여야 한다 (컨텍스트 스위칭) 중단 지점의 정보를 저장하고 사용할때 복원하기 위해 레지스터가 존재한다. (프로그램 카운터,  스택 포인터등의 정보 보유)
- 프로세스 상태
	- 프로세스의 현재 상태값을 저장
- CPU 스케줄링 정보
	- 프로세스를 언제, 어떤 순서로 CPU 자원을 할당 받을지에 대한 정보
- 메모리 정보
	-  프로세스가 저장되어 있는 주소에 대한 정보
	- 페이지 테이블 정보를 포함한다.
- 사용한 파일 및 입출력장치 정보
	- 할당한 입출력장치, 사용 중인 파일 정보

## 컨텍스트 스위칭

프로세스 실행 중 인터럽트에 의해 다른 프로세스로 실행 순서가 넘어가면  어떤 작업을 거쳐야 할까?

우선 기존에 실행되던 프로세스는 중간 정보를 백업해야한다.
- 프로그램 카운터 등 각종 레지스터 값, 메모리 값, 사용한 파일, 메모리 정보, 입출력장치 사용 기록
- 이러한 중간 정보를 context라고 한다
- 프로세스들은 이러한 백업 데이터를 바탕으로 실행을 복구한다.

#### 즉 컨텍스트 스위칭이란

기존의 실행중인 프로세스 정보를 백업하고 새로운 프로세스 실행을 위해 문맥을 복구하는 과정을 일컫는다. 동시성을 보장하기 위한 환경에서 컨텍스트 스위칭을 통해 여러 프로세스가 끊임없이 번갈아가며 실행되도록 한다.

![image](https://github.com/rech4210/rech4210.github.io/assets/65288322/c6102e9f-9acc-400a-8cfa-e95ee2f0e650)

### 프로세스의 메모리 영역
운영체제는 커널 영역에 적재된 PCB 정보를 바탕으로 프로세스를 관리한다. 그렇다면 사용자 영역에서는 프로세스가 어떻게 관리될까? 사용자 영역에서 프로세스는 메모리 영역을 구분하여 관리한다.

메모리 영역
- 코드영역
	- 실행할 수 있는 코드, 기계어로 이루어진 명령어 저장
	- 데이터가 아닌 CPU가 사용할 명령어가 담기기에 **쓰기가 금지**된 read only 영역이다

- 데이터 영역
	- 프로그램이 **실행되는 동안** 유지할 데이터 저장
	- 전역 변수, 정적 변수 ,BSS (초기화 x 또는 수식 및 함수에 의해 초기화된 변수)

> #### 코드와 데이터 영역은 프로그램 실행 시 크기가 고정되기에 정적 할당 공간이라 지칭한다.

<br>

- 힙 영역
	- 프로그램을 만드는 사용자, 프로그래머가 직접 할당할 수 있는 저장 공간.
	- 메모리 할당은 **반드시 해제** 또한 동반 되어야 하며, 이를 자동으로 관리해주는 것이 가비지 컬렉션이다.
	- 만약 메모리의 해제를 해주지 않는다면 memory leak가 발생한다.
	- 런타임에 크기가 결정
	- 낮은 주소에서 높은 주소로 할당
	- FIFO, 내부 구조가 트리로 구현되며 우선순위큐로 유리

- 스택 영역
	- 데이터를 일시적으로 저장하는 공간
	- 매개 변수, 지역 변수
	- 컴파일 타임에 크기가 결정
	- 높은 주소에서 낮은 주소로 할당
	- LIFO , 메모리 풀 사용에 유리 (스택 포인터)

> #### 프로그램 실행 중 동적으로 크기가 변할 수 있기에 동적 할당 공간이라 지칭한다.

둘의 크기는 가변적이므로 서로 간 증가하는 주소의 방향이 다르다.


## 프로세스 상태
![image](https://github.com/rech4210/rech4210.github.io/assets/65288322/3c95288e-8ff5-4acd-a75a-01110e78fa92)

- 생성 상태
	- 메모리에 적재되어 PCB를 할당 받은 상태
- 준비 상태
	- CPU 자원 할당을 기다리는 상태
	- 실행 상태로 진입하는것을 디스패치라고 함.
- 실행 상태
	- 타이머 인터럽트 발생시 준비 상태로 변경
	- 실행 도중 입출력장치를 사용하면 입출력 종료시까지 대기 상태로 변경
- 대기 상태 (blocked state)
	- 실행 도중 입출력장치를 사용하는 경우
	- CPU 대비 입출력 작업이 느리기에 대기 상태로 진입
	- 입출력 완료 인터럽트를 받으면 준비 상태로 전환
- 종료 상태
	- PCB, 프로세스 메모리 영역 정리

### 프로세스 계층 구조
> 윈도우 운영체제는 계층 구조를 가지고 있지 않으나, 대부분으 운영체제는 계층 구조로 프로세스를 관리한다.

프로세스 실행 도중 다른 프로세스 생성 가능
부모 프로세스
 : 새 프로세스를 생성한 프로세스
자식 프로세스
: 부모에 의해 생성된 프로세스

부모 프로세스와 자식 프로세스는 별개의 프로세스이므로 서로 다른 PID를 가진다.

### 프로세스 생성 기법
부모 프로세스는 자식 프로세스를 어떻게 만들고 자식 프로세스는 어떻게 자신의 코드를 실행시킬까?

복제와 옷 갈아입기
부모 프로세스는 fork 시스탬 호출을 통해 자신의 복사본을 자식 프로세스로 생성
자식 프로세스는 exec 시스템 호출을 통해 자신의 메모리 공간을 다른 프로그램으로 교체

fork 시스템 호출
- 복사본 생성 (자식프로세스로)
- 부모 프로세스의 자원 상속

exec 시스템 호출
- 메모리 공간을 새로운 프로그램으로 덮어쓰기
- 코드 / 데이터 영역은 실행할 프로그램 내용으로 바뀌고 나머지 영역은 초기화

![image](https://github.com/rech4210/rech4210.github.io/assets/65288322/9bee34ed-d1c9-4dd6-9465-60be4f2e8b75)

## 스레드
프로세스를 구성하는 실행 흐름의 단위
하나의 프로세스는 하나 이상의 스레드를 가질 수 있다.

![image](https://github.com/rech4210/rech4210.github.io/assets/65288322/1f6b4682-d4f3-42a0-8742-1d1f2dc35023)

실행 흐름이 여러 개인 프로세스를 멀티 스레드 프로세스라 한다.


### 스레드의 구성 요소

스레드 ID, 프로그램 카운터 등의 레지스터, 스택
스레드마다 실행에 필요한 최소한의 정보를 보유

![image](https://github.com/rech4210/rech4210.github.io/assets/65288322/ea6c0a20-059a-4aea-bc4e-dc6a644aa11c)

프로세스를 이루는 스레드는 서로간의 자원을 공유 할 수 있다.
최근 사용되는 방식으로는 CPU에게 작업을 전달할때 전달되는 단위를 스레드 단위로 하기도 한다.


## 멀티 프로세스 VS 멀티 스레드
멀티 프로세스 : 동일한 작업을 수행하는 단일 스레드 프로세스 여러 개 실행
- 프로세스간 자원을 공유하지않아 독립적으로 실행된다.
멀티 스레드 : 하나의 프로세스를 여러 스레드로 실행
- 스택, PC 레지스터 등을 제외한 자원을 공유하여 협력과 통신에 유리.
- 자원을 공유함으로써 문제가 발생할 수 있다.

### copy on write


### IPC
파일을 통한 프로세스 간 통신, 공유 메모리를 통한 프로세스 간 통신이 있다.


## CPU 바운드 IO 바운드

CPU 바운드
: 프로세스가 CPU 자원을 많이 사용하는 작업을 하는 경우

IO 바운드
: 프로세스가 IO 작업 및 네트워크 관련 작업을 하는 경우

해당 경우에 따라 스레드 할당수가 변할 수 있다.

CPU 바운드 같은 경우 CPU로부터 자원을 받는 경우가 많으며 CPU Burst (작업이 몰리는 경우)가 자주 발생하기에 스레드의 숫자를 코어와 동일하게 또는 +1 만큼 할당하는것이 context switching 을 고려하여 병목현상을 줄일 수 있다.

반대로 IO의 경우 CPU 바운드에 비해 많은 수의 스레드를 할당하여 사용할 수 있으나, 여건에 맞게 사용하여야 한다.


#### 스레드가 많으면 좋을까?
우선적으로 스레드가 사용될 환경을 봐야한다.
순차적으로 진행되는 프로그램의 경우 멀티스레드 환경이 큰 효과를 볼 수 없으며 코어의 성능을 넘는 스레드의 개수를 할당할 때 CPU 코어에 과도한 race condition이 발생하거나 context switching에 의해 병목이 발생할 수 있다.
또한 CPU bound인지 IO bound인지 고려하는것도 중요할 것이다. CPU burst가 자주 일어나는 CPU bound일 경우 스레드의 숫자를 과도하게 늘리는 것이 오히려 자원 사용성을 떨어뜨리는 결과를 불러올 수 있다.

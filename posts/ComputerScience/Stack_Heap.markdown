---
layout: post
title: "Stack과 Heap의 메모리적 관점"
description:
date: 2024-11-04 15:01:04 +0900
tags : ComputerScience
---

![image](https://github.com/rech4210/rech4210.github.io/assets/65288322/c63bb9ae-fdae-42bc-9490-4c064c5819d8)

### 1. 메모리 관리 영역과 포함 요소

메모리 관리는 일반적으로 다음과 같은 영역으로 나뉩니다:

- **코드(Code) 영역**: 프로그램의 기계어 코드가 저장되는 영역으로, 해당 영역에는 함수와 프로그램의 명령어가 포함되어 있다. 읽기 전용으로 실행 중에 코드가 변경되지 않는다. 함수가 코드 영역에 저장되는 이유를 알고싶다면.  [inline]() 키워드 알아보기.
	- 프로그램의 무결성 제공을 위해 읽기 전용 영역으로 지정된다.

- **리터럴(Literal) 영역**: 리터럴 값은 프로그램 실행 중 변경되지 않는 상수 값이다. 이러한 값들을 별도의 영역에 저장함으로써 메모리를 효율적으로 사용가능하다. 변경 불가능한 `Read-Only` 영역
	- 동일한 리터럴 값이 여러 곳에서 사용될 때, 이를 하나의 메모리 위치에 저장하고 참조할 수 있다.

- **데이터(Data) 영역**: 초기화가 된 전역 변수, 정적 변수가 저장되는 영역이다. 프로그램이 시작될 때 초기화된 상태로 존재하며 읽기/ 쓰기 권한이 존재한다.

- **BSS(Block Started by Symbol) 영역**: 초기화되지 않은 전역, 정적 변수가 저장되는 영역이다. 시작 될때 해당 변수들은 0으로 초기화된다. 초기화되지 않은 데이터는 BSS에 저장되어 실행 파일에 포함되지 않는다.

- **힙(Heap) 영역**: 동적 메모리 할당을 위해 사용되는 영역. 프로그램 실행 중에 `malloc`, `calloc`, `realloc` 등의 함수를 통해 메모리를 할당받고, `free` 함수를 통해 해제한다.

- **스택(Stack) 영역**: 함수 호출 시 지역 변수와 함수 호출 정보를 저장하는 영역. 함수가 호출될 때마다 스택 프레임이 생성되고, 함수가 종료되면 해당 스택 프레임이 해제됨. 고정된 크기가 컴파일 타임에 정해지며 이를 초과시 오버플로우 발생. 메모리 할당이 `높은 주소 -> 낮은 주소` 로 진행되며 이는 아래 이유가 존재한다.
	-  이렇게 하면 힙과 스택이 서로 반대 방향으로 확장되므로, 두 영역이 충돌할 가능성이 줄어든다.
	- 스택 오버플로우가 발생하면 낮은 주소로 확장되기 때문에, 중요한 데이터나 코드 영역을 덮어쓰는 것을 방지할 수 있다.

### 2. 힙과 스택의 차이점

- **힙(Heap)**:
	 - **할당 방식**: 동적 할당. `malloc`, `calloc`, `realloc` 등을 통해 필요할 때마다 메모리를 할당받고, `free`를 통해 해제한다.
	 - **크기**: 프로그램 실행 중에 동적으로 결정.
	 - **단편화**: 외부 단편화가 발생할 수 있습니다. 메모리 블록이 할당되고 해제되면서 빈 공간이 생기고, 이 빈 공간들이 서로 떨어져 있어 사용할 수 없는 메모리가 생길 수 있습니다.
		 - > 외부 단편화 해결 방법으로는 페이징 기법이 있다. [페이징]()
	 - **효율성**: 메모리 할당과 해제가 비교적 느립니다. 메모리 관리자가 빈 공간을 찾아야 하기 때문입니다.

- **스택(Stack)**:
	 - **할당 방식**: 정적 할당. 함수 호출 시 자동으로 메모리가 할당되고, 함수가 종료되면 자동으로 해제됩니다.
	 - **크기**: 고정된 크기의 스택이 할당되나, 실행 중 함수 호출에 따른 크기가 늘어나긴 한다.
	 - **단편화**: 내부 단편화가 발생할 수 있습니다. 스택 프레임이 고정된 크기로 할당되기 때문에, 사용되지 않는 메모리가 생길 수 있습니다.
		 - > 내부 단편화 해결 방법으로는 세그멘테이션 기법이 있다.
	 - **효율성**: 메모리 할당과 해제가 매우 빠릅니다. 스택 포인터를 이동시키는 것 만으로 메모리를 관리할 수 있기 때문입니다.

 **메모리 풀 (Memory Pool)**
	메모리 풀은 미리 정의된 크기의 메모리 블록을 여러 개 준비해두고, 필요할 때마다 이 블록을 할당하는 방법으로. 주로 고정 크기의 메모리 할당이 빈번한 경우에 사용됩니다. 멀티스레드 환경에서 힙에 요청하는 경우 매우 무거운 작업이 될 수 있기에 메모리 풀을 사용하기도 함.

용도에 따라 고정된 크기공간을 메모리풀로 사용할 수 도 있으며, 메모리 풀의 크기가 동적으로 바뀌는 경우도 존재한다.

내부 단편화를 줄일 수 있으며, 메모리 할당과 해제 속도가 빨라집니다.
- **장점**:
	 - 내부 단편화 감소
	 - 빠른 메모리 할당/해제


- **단점**:
	- 미리 메모리 공간을 잡아두기에 메모리 낭비가 발생할 수 있음.
	 - 외부 단편화 발생 가능
	 - 유연성 부족 (고정 크기의 블록만 할당 가능)

> 메모리 풀 단점
>

#### 장단점 비교

| 방법 | 외부 단편화 해결 | 내부 단편화 해결 | 메모리 관리 오버헤드 | 유연성 |
|---------------|------------------|------------------|----------------------|--------|
| 페이징 | 완전 해결 | 부분 해결 | 높음 | 높음 |
| 세그멘테이션 | 부분 해결 | 부분 해결 | 중간 | 높음 |
| 메모리 풀 | 부분 해결 | 거의 해결 | 낮음 | 낮음 |


### 3. 힙과 스택의 속도 차이가 나는 이유 (메모리 접근의 차이점)

CPU가 프로세스를 실행할 때, 가상 주소를 물리 주소로 변환하기 위해 페이지 테이블을 사용합니다. 힙과 스택은 메모리 할당 방식과 접근 방식에서 차이가 있습니다.


- **페이지 테이블:**

	- **힙(Heap)**:
		 - 동적 메모리 할당이 이루어지므로, 페이지 테이블에 새로운 페이지가 추가될 수 있습니다.
		 - 메모리 할당 시마다 페이지 테이블을 갱신해야 하므로, 페이지 폴트가 발생할 가능성이 있습니다.

	- **스택(Stack)**:
		 - 스택은 연속적인 메모리 블록으로 할당되므로, 페이지 테이블 갱신과 페이지 폴트가 적게 발생.


 - **CPU 사이클:**

	- **힙(Heap)**:
		 - 힙은 동적 메모리 할당과 해제를 위해 추가적인 연산이 필요하므로 CPU 사이클이 더 많이 소모됩니다.
		 - 힙은 전역적으로 관리되므로 컨텍스트 스위칭 시 힙 메모리 관리에 추가적인 오버헤드가 발생할 수 있습니다.

		 -  **커널 모드 진입**: 힙 메모리 할당은 일반적으로 사용자 모드에서 이루어지지만, 메모리 부족 시 커널 모드로 진입하여 추가 메모리를 요청할 수 있습니다. 이 과정은 시간이 더 걸릴 수 있습니다.
		 -  **캐시 효율성**: 스택 메모리는 연속적인 메모리 블록에 할당되므로 캐시 효율성이 높습니다. 반면, 힙 메모리는 메모리 단편화로 인해 비연속적인 블록에 할당될 수 있어 캐시 효율성이 떨어질 수 있습니다.


	- **스택(Stack)**:
		 - 스택은 LIFO(Last In, First Out) 구조로, 메모리 접근이 매우 빠릅니다. 함수 호출과 반환 시 스택 포인터를 조정하는 것만으로도 메모리 접근이 가능하므로 CPU 사이클이 적게 소모
		 - 스택은 각 스레드마다 독립적으로 존재하며, 스레드 컨텍스트 스위칭 시 스택 포인터만 변경하면 됩니다
		 - **스택 포인터 조작**: 함수가 호출되면 스택 포인터(stack pointer, SP)가 현재 스택 프레임의 시작 지점을 가리키고, 함수의 지역 변수와 반환 주소 등이 스택에 저장됩니다. 함수가 반환되면 스택 포인터가 이전 스택 프레임의 시작 지점으로 되돌아가면서 현재 스택 프레임이 해제됩니다.

		  - **자동 메모리 관리**: 컴파일러는 함수 호출과 반환 시 스택 포인터를 적절히 조작하는 코드를 생성합니다. 이를 통해 함수의 메모리가 자동으로 할당되고 해제됩니다.


 - **메모리 관리:**  
	- **힙(Heap)**:
		 - 힙은 동적 메모리 할당에 의해 관리되며, 메모리 단편화와 같은 문제가 발생할 수 있습니다. 힙 메모리 관리는 더 복잡하고 시간이 많이 소요될 수 있습니다.

	- **스택(Stack)**:
		- 스택은 운영체제에 의해 자동으로 관리되며, 함수 호출과 반환 시 자동으로 메모리가 할당되고 해제됩니다.



### 4. 멀티태스크 환경에서 스레드 간 스택 자료구조만 따로 존재하는 이유

멀티태스크 환경에서 각 스레드는 독립적인 실행 흐름을 가지며, 각 스레드는 자신의 스택을 가지고 있습니다. 이는 다음과 같은 이유 때문입니다:

- **독립적인 함수 호출**:  멀티스레드 환경에서 스레드는 독립적으로 함수 호출을 수행하므로, 각 스레드마다 독립적인 스택을 필요로한다. 스택에는 함수 호출 정보와 지역 변수가 저장되므로, 스레드간 충돌 방지를 위한 독립적인 스택이 필요하다.

- **메모리 보호**: 스레드 간의 스택이 분리되어 있으면, 한 스레드가 다른 스레드의 스택을 침범하는 것을 방지할 수 있습니다. 이는 메모리 보호와 안정성을 높이는 데 기여합니다.

- **컨텍스트 스위칭**: 멀티태스크 환경에서 스레드 간의 컨텍스트 스위칭이 발생할 때, 각 스레드의 스택 포인터를 저장하고 복원해야 합니다. 독립적인 스택을 사용하면, 스레드 간의 컨텍스트 스위칭이 더 효율적으로 이루어질 수 있습니다.

#### **멀티스레드 환경에서 컨텍스트 스위칭 시 PCB에 저장되는 요소들**:

 프로세스 제어 블록(PCB, Process Control Block)은 프로세스의 상태를 저장하는 데이터 구조입니다.

 - **프로세스 상태**: 실행 중, 준비 상태, 대기 상태 등 프로세스의 현재 상태.
 - **프로세스 식별자(PID)**: 프로세스를 고유하게 식별하는 식별자.
 - **프로그램 카운터(PC)**: 프로세스가 실행 중인 명령어의 주소.
 - **CPU 레지스터**: 일반 목적 레지스터, 스택 포인터, 베이스 포인터 등 CPU 레지스터의 값.
 - **메모리 관리 정보**: 페이지 테이블, 세그먼트 테이블 등 프로세스의 메모리 관리 정보.
 - **스케줄링 정보**: 프로세스 우선순위, 스케줄링 큐 포인터 등 스케줄링 관련 정보.
 - **입출력 상태 정보**: 열린 파일 목록, 입출력 장치 상태 등 입출력 관련 정보.
